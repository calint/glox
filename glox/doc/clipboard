//	m3 m;
//	cin>>m;
//	cout<<m;
//	m3 m;
//	m.ident();
//	m.transl(p3(1,0,1));
//	p3 z;
//	m.axisz(z);
//	cout<<m<<endl;
//	cout<<z<<endl;
//	p3 p;
//	m.mult(p3(1,0,0),p);
//	cout<<p<<endl;
	//	flf();ll();
	//	bvol::checkcol(p3(),m3(),bvol(1,p3(1,1,1)),p3(1,0,0),m3(),bvol(1,p3(1,1,1)));
	//	throw signl(1,"gnoxstop");


//		glutSetKeyRepeat(GLUT_KEY_REPEAT_ON);
//		glutSetKeyRepeat(GLUT_KEY_REPEAT_OFF);


//		cout<<glGetString(GL_VENDOR)<<"  "<<glGetString(GL_VERSION)<<"  "<<glGetString(GL_VERSION)<<"  glsl "<<GL_SHADING_LANGUAGE_VERSION<<endl;
//		cout<<"opengl("<<glGetString(GL_VERSION)<<")"<<" glsl("<<GL_SHADING_LANGUAGE_VERSION<<")"<<endl;



		glDisable(GL_DEPTH_TEST);
		glDisable(GL_CULL_FACE);
		glDisable(GL_LIGHTING);
		glEnable(GL_BLEND);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glBegin(GL_QUADS);
		glColor3b(0x7f,0,0);
		glVertex2f(0,0);
		glVertex2f(.5f,0);
		glVertex2f(.5f,.5f);
		glVertex2f(0,.5f);
		glEnd();
		glOrtho(0,w,0,h,-1000,1000);
		glBegin(GL_QUADS);
		glColor3b(0x7f,0,0);
		glVertex2f(0,0);
		glVertex2f(w>>1,0);
		glVertex2f(w>>1,h>>1);
		glVertex2f(0,h>>1);
		glEnd();




		bvol a(1,p3(1,1,1));
		bvol b(2,p3(2,1,1));
		ofstream ofs("bvol.cin");
		ofs<<a<<endl;
		ofs.close();
		ifstream ifs("bvol.cin");
		ifs>>b;
		ifs.close();
		cout<<b<<endl;


		bool col=bvol::checkcol(p3(),a,p3(),b);
		cout<<"collision: "<<col<<endl;
		cout<<"collision: "<<bvol::checkcol(p3(3,0,0),a,p3(),b)<<endl;



at start or end of frame
 glBufferSubData, glBufferData, glMapBuffer, glTexSubImage, glCopyTexImage, glCopyTexSubImage, glReadPixels, glBindFramebuffer, glFlush, and glFinish.




Table 3-3  OpenGL ES 1.1 values
Maximum number of texture units available to the fixed function pipeline
GL_MAX_TEXTURE_UNITS
Maximum number of clip planes
GL_MAX_CLIP_PLANES




Table 3-2  OpenGL ES 2.0 shader values
Maximum number of vertex attributes
GL_MAX_VERTEX_ATTRIBS
Maximum number of uniform vertex vectors
GL_MAX_VERTEX_UNIFORM_VECTORS
Maximum number of uniform fragment vectors
GL_MAX_FRAGMENT_UNIFORM_VECTORS
Maximum number of varying vectors
GL_MAX_VARYING_VECTORS
Maximum number of texture units usable in a vertex shader
GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
Maximum number of texture units usable in a fragment shader
GL_MAX_TEXTURE_IMAGE_UNITS






default precision highp; // Default precision declaration is required in fragment shaders.
uniform lowp sampler2D sampler; // Texture2D() result is lowp.
varying lowp vec4 color;
varying vec2 texCoord;   // Uses default highp precision.
 
void main()
{
    gl_FragColor = color * texture2D(sampler, texCoord);
}


/** Initialization-time for shader **/
            GLuint shader, prog;
            GLchar *shaderText = "... shader text ...";

            // Create ID for shader
           shader = glCreateShader(GL_VERTEX_SHADER);

           // Define shader text
           glShaderSource(shaderText);

           // Compile shader
           glCompileShader(shader);

           // Associate shader with program
           glAttachShader(prog, shader);

          // Link program
           glLinkProgram(prog);
    
           // Validate program
           glValidateProgram(prog);

           // Check the status of the compile/link
           glGetProgramiv(prog, GL_INFO_LOG_LENGTH, &logLen);
           if(logLen > 0)
           {
               // Show any errors as appropriate
               glGetProgramInfoLog(prog, logLen, &logLen, log);
               fprintf(stderr, "Prog Info Log: %s\n", log);
       }

     // Retrieve all uniform locations that are determined during link phase
           for(i = 0; i < uniformCt; i++)
           {
               uniformLoc[i] = glGetUniformLocation(prog, uniformName);
           }

           // Retrieve all attrib locations that are determined during link phase
           for(i = 0; i < attribCt; i++)
           {
               attribLoc[i] = glGetAttribLocation(prog, attribName);
           }

    /** Render stage for shaders **/
    glUseProgram(prog);



glGenTextures(1, &spriteTexture);
glBindTexture(GL_TEXTURE_2D, spriteTexture);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, spriteData);


glGetIntegerv(GL_MAX_TEXTURE_UNITS)





glDisable(GL_DITHER);
glDisable(GL_ALPHA_TEST);
glDisable(GL_BLEND);
glDisable(GL_STENCIL_TEST);
glDisable(GL_FOG);
glDisable(GL_TEXTURE_2D);
glDisable(GL_DEPTH_TEST);






typedef struct _vertexStatic
{
    GLfloat position[2];
} vertexStatic;
 
typedef struct _vertexDynamic
{
    GLubyte color[4];
} vertexDynamic;
 
// Separate buffers for static and dynamic data.
GLuint    staticBuffer;
GLuint    dynamicBuffer;
GLuint    indexBuffer;
 
const vertexStatic staticVertexData[] = {...};
vertexDynamic dynamicVertexData[] = {...};
const GLubyte indices[] = {...};
 
void CreateBuffers()
{
// Static position data
    glGenBuffers(1, &staticBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, staticBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(staticVertexData), staticVertexData, GL_STATIC_DRAW);
 
// Dynamic color data
// While not shown here, the expectation is that the data in this buffer changes between frames.
    glGenBuffers(1, &dynamicBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, dynamicBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(dynamicVertexData), dynamicVertexData, GL_DYNAMIC_DRAW);
 
// Static index data
    glGenBuffers(1, &indexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
}
 
void DrawModelUsingMultipleVertexBuffers()
{
    glBindBuffer(GL_ARRAY_BUFFER, staticBuffer);
    glVertexAttribPointer(ATTRIB_POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(vertexStruct), (void*)offsetof(vertexStruct,position));
    glEnableVertexAttribArray(ATTRIB_POSITION);
 
    glBindBuffer(GL_ARRAY_BUFFER, dynamicBuffer);
    glVertexAttribPointer(ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(vertexStruct), (void*)offsetof(vertexStruct,color);
    glEnableVertexAttribArray(ATTRIB_COLOR);
 
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glDrawElements(GL_TRIANGLE_STRIP, sizeof(indices)/sizeof(GLubyte), GL_UNSIGNED_BYTE, (void*)0);
}





GLuint    vertexBuffer;
GLuint    indexBuffer;
 
void CreateVertexBuffers()
{
 
    glGenBuffers(1, &vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
 
    glGenBuffers(1, &indexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
 
}



GLuint    vertexBuffer;
GLuint    indexBuffer;
 
void CreateVertexBuffers()
{
 
    glGenBuffers(1, &vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
 
    glGenBuffers(1, &indexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
 
}


	cout.setf(ios::fixed,ios::floatfield);
	cout.setf(ios::showpoint);
	cout.precision(2);



void gnox_sandbox(){
//	cout<<cin.rdbuf();
	ofstream ofs("p3.cout");
	if(!ofs.good())throw"fileopenerr";
	p3 po(1,2,3.33333);
	cout<<po<<endl;
	ofs<<po<<endl;
	if(!ofs.good())throw"filewriteerr";
	ofs.close();
	po=p3();
	ifstream ifs("p3.cout");
	if(!ifs.good())throw"fileopenerr";
	ifs>>po;
	ifs.close();
	cout<<po<<endl;
	p3 p=p3();
	cin>>p;
	if(!cin.good())throw"cinreaderr";
	cout<<p<<endl;
	cin>>p;
	cout<<p<<endl;
}





	cout<<cin.rdbuf();
	ofstream ofs("p3.cout");
	p3 po(1,2,3.33333);
	cout<<po<<endl;
	ofs<<po<<endl;
	ofs.close();;
	ifstream ifs("p3.cout");
	ifs>>po;
	ifs.close();
	cout<<po<<endl;
	p3 p=p3();
	cin>>p;
	cout<<p<<endl;
	cin>>p;
	cout<<p<<endl;


// redirecting cout's output
#include <iostream>
#include <fstream>
using namespace std;

int main () {
  streambuf *psbuf, *backup;
  ofstream filestr;
  filestr.open ("test.txt");
  backup = cout.rdbuf();     // back up cout's streambuf
  psbuf = filestr.rdbuf();   // get file's streambuf
  cout.rdbuf(psbuf);         // assign streambuf to cout
  cout << "This is written to the file";
  cout.rdbuf(backup);        // restore cout's original streambuf
  filestr.close();
  return 0;
}


 cout<<cin.rdbuf();


#include <iostream>
using namespace std;
int main () {
  cout.setf ( ios_base::hex, ios_base::basefield );  // set hex as the basefield
  cout.setf ( ios_base::showbase );                  // activate showbase
  cout << 100 << endl;
  cout.unsetf ( ios_base::showbase );                // deactivate showbase
  cout << 100 << endl;
  return 0;
}

g++ -nostartfiles -nodefaultlibs -nostdlib

class xser{
private:
	FILE*in;
	FILE*out;
public:
	xser(FILE*in,FILE*out):in(in),out(out){}
	xser&w(const size_t d){fprintf(out,"%lu ",d);return*this;}
	xser&r(size_t&d){fscanf(in,"%lu ",&d);return*this;}
	xser&w(const char*b,const size_t size=0){fprintf(out,"%lu %s ",size?size:strlen(b),b);return*this;}
	xser&r(char**buf,size_t&size){
		if(*buf)
			delete *buf;//?
		fscanf(in,"%lu ",&size);
		*buf=new char[size];
		const size_t s=fread(*buf,size,1,in);
		if(s!=1){
			perror("rs");
			throw "error while reading";
//			exit(101);
		}
		return*this;
	}
	xser&r(char**buf){size_t size=0;return r(buf,size);}
	xser&flush(){fflush(out);return*this;}
};

//try{return window::main(0,NULL);}
//catch(const char*p){cout<<"••• error: "<<p<<endl;stktrace();}
//catch(const void*p){cout<<"•• error: "<<p<<" "<<p<<endl;stktrace();}
//catch(...){cerr<<"• error:"<<endl;stktrace();}


//inline static void f(const char&c){cout<<c;}
//inline static void f2(char&c){cout<<c;c=' ';}
//	char s[]="jello world";
//	puts(s);
//	array<const char>a=array<const char>("hello world",0,3);
//	a.ro(0,a.len(),f);
//	a.rw(0,a.len(),f);
//	cout<<endl;
//	array<char>b=array<char>(s,0,3);
//	b.ro(0,a.len(),f);
//	b.rw(0,a.len(),f2);
//	cout<<endl;
//	puts(s);

// ⦾⦿⧀⧁ ⊕⊖⊗⊘⊙⊚⊛⊜⊝ ℹ⏩⏪⏫⏬⛎✅❎  ㋞㋡


static void main_sigf(const int a){
	cout<<" ⦿ terminated with signal "<<a<<endl;
	exit(a);
}
int main(){
	for(int i=0;i<32;i++)signal(i,main_sigf);
	return window::main(0,NULL);
}


//		throw signl(2,"exception");
//		throw signl(__LINE__,__FUNCTION__);





//		for(vector<obj*>::iterator it=chs.begin();it!=chs.end();++it){
//			(*it)->draw();
//		}


		lut<bool>lutc=lut<bool>();
		const unsigned char ch='a';
		const char ke[]={ch,0};
		cout<<lutc[ke]<<endl;
		lutc.put(ke,true);
		cout<<lutc[ke]<<endl;
		lutc.put(ke,false);
		cout<<lutc[ke]<<endl;
